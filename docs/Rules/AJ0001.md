# AJ0001 - Missing equality comparer

## Explanation

When using reference types which do not override `GetHashCode()` for keys
in hashsets, dictionaries etc., the results can be unpredicatable.

Value types on the other hand, use structural comparison and are excluded from this rule. However, it's best practice to
implement
`IEquatable<T>` and override `GetHashCode()` for those types as well because of performance reasons. There's already
another analyzer for that. See https://github.com/meziantou/Meziantou.Analyzer/blob/main/docs/Rules/MA0066.md

There are two possibilities to solve this issue:

- Override `GetHashCode()` and optionally implement `IEquatable<T>` or at least override `Equals(object)`
- Use `IEqualityComaprer<T>` argument

## Examples:

All the classes will use the following types class which does not implement `IEquatable<T>` and does not override
`GetHashCode()`:

````csharp
public sealed class RefType // Does not implement IEquatable<T> and does not override GetHashCode()
{
    public string StringValue { get; set; }
    public int IntValue { get; set; }    
}

public sealed class PartialEquatableRefType : IEquatable<PartialEquatableRefType> // does not override GetHashCode()
{
    public string StringValue { get; set; }
    public int IntValue { get; set; }
    
    public bool Equals(PartialEquatableRefType? other)
        => other is not null
            && IntValue == other.IntValue
            && StringValue == other.StringValue;
}

public sealed class FullEquatableRefType : IEquatable<FullEquatableRefType> // overrides GetHashCode()
{
    public string StringValue { get; set; }
    public int IntValue { get; set; }
    
    public bool Equals(FullEquatableRefType? other)
        => other is not null
            && IntValue == other.IntValue
            && StringValue == other.StringValue;

    public override int GetHashCode() => HashCode.Combine(StringValue, IntValue);
}

````

```csharp
// FullEquatableRefType
new FullEquatableRefType[0].ToDictionary(a=>a, a=>a ); // OK
new FullEquatableRefType[0].ToHashSet(); // OK
new FullEquatableRefType[0].ToDictionary(a=>a, a=>a, new FullEquatableRefTypeEqualityComarer() ); // OK
new FullEquatableRefType[0].ToHashSet(new FullEquatableRefTypeEqualityComarer() ); // OK

// PartialEquatableRefType -> does not override GetHashCode()
new PartialEquatableRefType[0].ToDictionary(a=>a, a=>a ); // not compliant
new PartialEquatableRefType[0].ToHashSet(); // not compliant
new PartialEquatableRefType[0].ToDictionary(a=>a, a=>a, new PartialEquatableRefTypeEqualityComarer() ); // OK
new PartialEquatableRefType[0].ToHashSet(new PartialEquatableRefTypeEqualityComarer() ); // OK

// PartialEquatableRefType -> does implement IEquatable<T> and does not override GetHashCode()
new RefType[0].ToDictionary(a=>a, a=>a ); // not compliant
new RefType[0].ToHashSet(); // not compliant
new RefType[0].ToDictionary(a=>a, a=>a, new PartialEquatableRefTypeEqualityComparer()); // OK
new RefType[0].ToHashSet(new PartialEquatableRefTypeEqualityComparer()); // OK
```

## Coverage

The following LINQ extension methods are covered by the analyzer:

| Namespace                    | Class Name          | Method Name           |
|:-----------------------------|:--------------------|:----------------------|
| System.Linq                  | Enumerable          | Contains              |
| System.Linq                  | Enumerable          | Distinct              |
| System.Linq                  | Enumerable          | DistinctBy            |
| System.Linq                  | Enumerable          | Except                |
| System.Linq                  | Enumerable          | ExceptBy              |
| System.Linq                  | Enumerable          | GroupBy               |
| System.Linq                  | Enumerable          | GroupJoin             |
| System.Linq                  | Enumerable          | Intersect             |
| System.Linq                  | Enumerable          | IntersectBy           |
| System.Linq                  | Enumerable          | Join                  |
| System.Linq                  | Enumerable          | SequenceEqual         |
| System.Linq                  | Enumerable          | ToDictionary          |
| System.Linq                  | Enumerable          | ToHashSet             |
| System.Linq                  | Enumerable          | ToLookup              |
| System.Linq                  | Enumerable          | Union                 |
| System.Linq                  | Enumerable          | UnionBy               |
| System.Collections.Immutable | ImmutableDictionary | Create                |
| System.Collections.Immutable | ImmutableDictionary | CreateRange           |
| System.Collections.Immutable | ImmutableDictionary | CreateBuilder         |
| System.Collections.Immutable | ImmutableDictionary | ToImmutableDictionary |
| System.Collections.Immutable | ImmutableHashSet    | Create                |
| System.Collections.Immutable | ImmutableHashSet    | CreateRange           |
| System.Collections.Immutable | ImmutableHashSet    | CreateBuilder         |
| System.Collections.Immutable | ImmutableHashSet    | ToImmutableHashSet    |
| System.Collections.Frozen    | FrozenDictionary    | ToFrozenDictionary    |
| System.Collections.Frozen    | FrozenSet           | ToFrozenSet           |

The following type constructions are covered by the analyzer:

| Namespace                      | Class Name        |
|:-------------------------------|:------------------|
| System.Collections.Generic     | Dictionary        |
| System.Collections.Generic     | HashSet           |
| System.Collections.Specialized | OrderedDictionary |

## Configuration

| Configuration Key (.editorconfig) | Description                                          |
|:----------------------------------|:-----------------------------------------------------|
| `AJ0001.is_enabled`               | Enables or disables the analyzer. Default is `true`. |
